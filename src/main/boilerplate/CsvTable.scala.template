package com.github.akiomik.scalatest

import java.io.{Reader, IOException}
import scala.io.{Source, BufferedSource}

import kantan.csv._
import kantan.csv.ops._
import kantan.csv.generic._
import org.scalatest.prop.Tables._

object CsvTable {
  implicit val sourceInput: CsvSource[BufferedSource] = CsvSource[Reader].contramap(_.reader)

  private def unsafeReadHeader[S <% CsvSourceOps[S], H: HeaderDecoder](csv: S): H = {
    val reader = csv.asUnsafeCsvReader[H](rfc)

    if (!reader.hasNext)
      throw new IOException("An empty csv passed.")

    reader.next
  }

  [#private def apply[S <% CsvSourceOps[S], [#T1#]](csv: S)(
    implicit
    headerDecoderH: HeaderDecoder[([#String#])],
    headerDecoderT: HeaderDecoder[([#T1#])]
  ) =
    Table(
      unsafeReadHeader[S, ([#String#])](csv),
      csv.unsafeReadCsv[Seq, ([#T1#])](rfc.withHeader): _*
    )#

  ]

  [#def fromString[[#T1#]](csv: String)(implicit headerDecoder: HeaderDecoder[([#T1#])]) =
    apply[String, [#T1#]](csv)#

  ]

  [#def fromFile[[#T1#]](name: String)(implicit headerDecoder: HeaderDecoder[([#T1#])]) = {
    val s = Source.fromFile(name)
    try apply[BufferedSource, [#T1#]](s)
    finally s.close
  }#

  ]

  [#def fromResource[[#T1#]](name: String)(implicit headerDecoder: HeaderDecoder[([#T1#])]) = {
    val s = Source.fromResource(name)
    try apply[BufferedSource, [#T1#]](s)
    finally s.close
  }#

  ]

}
